---
description: テストプロジェクトの構造と実装ガイド 単体テストの命名規則とパターン モックの使用方法 テストカバレッジの目標 今後の拡張計画
globs: 
alwaysApply: false
---
# Metasia テストガイドライン

## テストプロジェクト構造

### プロジェクト分割
- **Metasia.Core.Tests**: Coreライブラリの単体テスト
- **Metasia.Editor.Tests**: Editorアプリケーションの単体テスト
- **Test**: 既存の統合テスト（MainWindowViewModelのテスト）

### ディレクトリ構造
テストプロジェクトは本体プロジェクトのディレクトリ構造をミラーリング：
```
Metasia.Core.Tests/
├── Objects/
│   ├── MetasiaObjectTests.cs
│   ├── LayerObjectTests.cs
│   ├── TimelineObjectTests.cs
│   ├── TextTests.cs
│   └── kariHelloObjectTests.cs
└── Metasia.Core.Tests.csproj

Metasia.Editor.Tests/
├── Models/
│   ├── EditCommands/
│   │   ├── EditCommandManagerTests.cs
│   │   └── Commands/
│   │       ├── ClipResizeCommandTests.cs
│   │       └── LayerIsActiveChangeCommandTests.cs
│   ├── FileSystem/
│   │   ├── FileEntityTests.cs
│   │   └── DirectoryEntityTests.cs
│   ├── Projects/
│   │   ├── MetasiaEditorProjectTests.cs
│   │   ├── MetasiaProjectFileTests.cs
│   │   └── TimelineFileTests.cs
│   └── Tools/
│       └── ProjectTool/
│           └── FileTreeNodeTests.cs
└── Metasia.Editor.Tests.csproj
```

## テスト命名規則

### テストクラス名
- `{テスト対象クラス名}Tests` (例: `MetasiaObjectTests`)

### テストメソッド名
- `{メソッド名}_{シナリオ}_{期待結果}` パターン
- 例:
  - `Constructor_WithId_SetsIdCorrectly`
  - `CanPlaceObjectAt_WithOverlap_ReturnsFalse`
  - `Execute_UpdatesStartAndEndFrames`

### テストケース命名
- パラメータ化テストでは説明的な値を使用
- 例: `[TestCase("image.png", FileTypes.Image)]`

## テストフレームワーク

### 使用ライブラリ
- **NUnit 3.14.0**: テストフレームワーク
- **Moq 4.20.72**: モッキングフレームワーク
- **Microsoft.NET.Test.Sdk 17.8.0**: テスト実行環境

### 基本的なテスト構造
```csharp
[TestFixture]
public class ExampleTests
{
    private ExampleClass _example;

    [SetUp]
    public void Setup()
    {
        _example = new ExampleClass();
    }

    [TearDown]
    public void TearDown()
    {
        // クリーンアップ処理
    }

    [Test]
    public void MethodName_Scenario_ExpectedResult()
    {
        // Arrange
        var input = "test";

        // Act
        var result = _example.Method(input);

        // Assert
        Assert.That(result, Is.EqualTo("expected"));
    }
}
```

## モックの使用

### インターフェースのモック
```csharp
var mockCommand = new Mock<IEditCommand>();
mockCommand.Setup(c => c.Description).Returns("Test Command");
mockCommand.Setup(c => c.Execute()).Verifiable();

// 使用
_manager.Execute(mockCommand.Object);

// 検証
mockCommand.Verify(c => c.Execute(), Times.Once);
```

### ファイルシステムのモック
```csharp
var mockFileEntity = new Mock<IFileEntity>();
mockFileEntity.Setup(f => f.Name).Returns("test.txt");
mockFileEntity.Setup(f => f.Path).Returns("/path/to/test.txt");
mockFileEntity.Setup(f => f.FileType).Returns(FileTypes.Text);
```

## テストパターン

### AAA (Arrange-Act-Assert) パターン
すべてのテストで一貫して使用：
```csharp
[Test]
public void TestMethod()
{
    // Arrange - テストの準備
    var obj = new TestObject();
    
    // Act - テスト対象の実行
    var result = obj.DoSomething();
    
    // Assert - 結果の検証
    Assert.That(result, Is.True);
}
```

### パラメータ化テスト
```csharp
[TestCase(0, true)]
[TestCase(50, true)]
[TestCase(100, true)]
[TestCase(-1, false)]
[TestCase(101, false)]
public void IsExistFromFrame_ReturnsCorrectValue(int frame, bool expected)
{
    // テスト実装
}
```

### 例外テスト
```csharp
[Test]
public void Constructor_WithInvalidPath_ThrowsException()
{
    // Act & Assert
    var ex = Assert.Throws<DirectoryNotFoundException>(() => 
        new DirectoryEntity("nonexistent"));
    Assert.That(ex.Message, Does.Contain("が見つかりません"));
}
```

## ファイルシステムテスト

### 一時ディレクトリの使用
```csharp
private string _testDirectory;

[SetUp]
public void Setup()
{
    _testDirectory = Path.Combine(Path.GetTempPath(), "MetasiaTests");
    Directory.CreateDirectory(_testDirectory);
}

[TearDown]
public void TearDown()
{
    if (Directory.Exists(_testDirectory))
    {
        Directory.Delete(_testDirectory, true);
    }
}
```

## テストのベストプラクティス

### 1. 単一責任の原則
- 1つのテストメソッドは1つの振る舞いのみをテスト
- 複数のアサーションは関連する場合のみ許可

### 2. 独立性
- テストは実行順序に依存しない
- 各テストは独立して実行可能

### 3. 再現性
- テストは常に同じ結果を返す
- ランダム値や現在時刻に依存しない

### 4. 可読性
- テスト名は何をテストしているか明確に
- Arrangeセクションで意図を明確に

### 5. 保守性
- プロダクションコードの変更に強い
- 実装の詳細ではなく振る舞いをテスト

## カバレッジ目標

### 優先順位
1. **ビジネスロジック** (EditCommands, Objects): 90%以上
2. **ユーティリティ** (FileSystem, Serializers): 80%以上
3. **UI関連** (ViewModels): 70%以上
4. **Views**: 手動テストで補完

### 除外対象
- 自動生成コード
- 単純なプロパティ（getterのみ）
- UIの見た目に関するコード

## 今後の拡張

### 統合テスト
- プロジェクトの保存/読み込みの完全なフロー
- レンダリングパイプラインのテスト
- Undo/Redoの複雑なシナリオ

### パフォーマンステスト
- 大規模プロジェクトの処理時間
- メモリ使用量の監視
- レンダリング速度の測定

### UIテスト
- Avalonia.Headlessを使用したUIテスト
- ViewModelの相互作用テスト
- コマンドバインディングのテスト
