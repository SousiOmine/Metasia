---
description: C#命名規則とコーディング規約 MVVMパターンのベストプラクティス EditCommandパターンの実装ガイド リソース管理とパフォーマンス最適化
globs: 
alwaysApply: false
---
# Metasia コーディング規約

## 命名規則

### C# 命名規則
- **クラス名**: PascalCase (例: `TimelineObject`, `LayerObject`)
- **インターフェース**: `I`プレフィックス + PascalCase (例: `IMetaDrawable`, `IEditCommand`)
- **メソッド名**: PascalCase (例: `DrawExpresser`, `AudioExpresser`)
- **プロパティ**: PascalCase (例: `StartFrame`, `EndFrame`)
- **プライベートフィールド**: `_`プレフィックス + camelCase (例: `_timeline`, `_frame_per_DIP`)
- **パラメータ/ローカル変数**: camelCase (例: `frame`, `targetObject`)

### ファイル構成
- 1ファイル1クラス原則
- ファイル名はクラス名と一致
- ViewModelは`*ViewModel.cs`
- Viewは`*View.axaml`と`*View.axaml.cs`

## MVVMパターンのベストプラクティス

### ViewModelの実装
```csharp
public class ExampleViewModel : ViewModelBase
{
    // ReactiveUIを使用したプロパティ
    private string _title;
    public string Title
    {
        get => _title;
        set => this.RaiseAndSetIfChanged(ref _title, value);
    }

    // コマンドの実装
    public ICommand SaveCommand { get; }

    public ExampleViewModel()
    {
        SaveCommand = ReactiveCommand.Create(ExecuteSave);
    }
}
```

### Viewのバインディング
```xml
<UserControl x:DataType="vm:ExampleViewModel">
    <TextBlock Text="{Binding Title}"/>
    <Button Command="{Binding SaveCommand}"/>
</UserControl>
```

## EditCommandパターン

### 新しいコマンドの実装
```csharp
public class NewEditCommand : IEditCommand
{
    private readonly TargetObject _target;
    private readonly OldValue _oldValue;
    private readonly NewValue _newValue;

    public void Execute()
    {
        // 変更を適用
        _target.Value = _newValue;
    }

    public void Undo()
    {
        // 変更を元に戻す
        _target.Value = _oldValue;
    }
}
```

## オブジェクトの実装

### 描画可能オブジェクト
```csharp
public class CustomObject : MetasiaObject, IMetaDrawable
{
    public void DrawExpresser(ref DrawExpresserArgs e, int frame)
    {
        // 1. nullチェック
        if (e.Bitmap is null) 
            e.Bitmap = new SKBitmap(width, height);

        // 2. 描画処理
        using (var canvas = new SKCanvas(e.Bitmap))
        {
            // 描画ロジック
        }

        // 3. サイズ情報の設定
        e.ActualSize = new SKSize(e.Bitmap.Width, e.Bitmap.Height);
        e.TargetSize = e.TargetResolution;
    }
}
```

## リソース管理

### Disposeパターン
```csharp
// SKBitmapなどのリソースは必ずusingで管理
using (var bitmap = new SKBitmap(width, height))
using (var canvas = new SKCanvas(bitmap))
{
    // 処理
}

// DrawExpresserArgsのDispose
express.Dispose();
```

## JSONシリアライズ

### シリアライズ可能なプロパティ
```csharp
public class SerializableObject
{
    [JsonInclude]
    public List<Item> Items { get; private set; }

    [JsonIgnore]
    public RuntimeData Cache { get; set; }
}
```

## 非同期処理

### async/awaitパターン
```csharp
public async Task<bool> SaveProjectAsync()
{
    try
    {
        await File.WriteAllTextAsync(path, content);
        return true;
    }
    catch (Exception ex)
    {
        // エラーハンドリング
        return false;
    }
}
```

## エラーハンドリング

### 例外処理
- ユーザー操作に関わる処理は必ずtry-catchで保護
- ファイルI/Oは特に注意
- nullチェックを適切に行う

```csharp
if (targetObject is null)
{
    return;
}

try
{
    // 危険な操作
}
catch (SpecificException ex)
{
    // 具体的なエラー処理
}
```

## パフォーマンス考慮事項

### レンダリング最適化
- 不要な再描画を避ける
- ビットマップの再利用
- 大きなコレクションにはObservableCollectionを慎重に使用

### メモリ管理
- 大きなオブジェクトは適切にDispose
- イベントハンドラーの購読解除
- WeakReferenceの活用

## テスト可能な設計

### 依存性注入
```csharp
public class ViewModel
{
    private readonly IFileDialogService _fileDialog;

    public ViewModel(IFileDialogService fileDialog)
    {
        _fileDialog = fileDialog;
    }
}
```

### インターフェースの活用
- 外部依存はインターフェース経由
- モックしやすい設計
- 単体テストを意識した実装

